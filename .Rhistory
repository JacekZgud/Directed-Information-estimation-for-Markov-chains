- mt: P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
Returns:
fr - simulation vector
"
y = fr$y
ft = fr$ft # probability of P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
mt = fr$mt # P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
for (i in 1:n) {
colmn = prob_cols[i]
mt[i] = sum(as.vector(unlist(Py[as.list(c(y)), ..colmn])) * as.vector(unlist(ft["prob"])))
}
Y = sample.int(n, 1, prob = mt) - 1
ft_1 = P[as.list(c(Y,y)), sum(prob), by = eval(paste(colnames(configs), "(t)", sep =""))]
print(ft_1)
print(ft)
colnames(ft_1) = c(colnames(configs), "prob")
print(ft_1)
ft$prob = ft$prob*ft_1$prob / sum(ft$prob*ft_1$prob)
fr$y = Y
fr$ft = data.frame(ft)
fr$mt = mt
return(fr)
}
markov_sim_Y(process, 3,"Y")
stepY <- function(fr, configs, Py, target, P, prob_cols) {
"
Simulate step of markov process with marginalized variables without conditioning
--------------------
Arguments:
fr - simulation vector consisting of y,ft,mt
- y: Y(t) simulated
- ft: P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
- mt: P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
Returns:
fr - simulation vector
"
y = fr$y
ft = fr$ft # probability of P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
mt = fr$mt # P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
for (i in 1:n) {
colmn = prob_cols[i]
mt[i] = sum(as.vector(unlist(Py[as.list(c(y)), ..colmn])) * as.vector(unlist(ft["prob"])))
}
Y = sample.int(n, 1, prob = mt) - 1
ft_1 = P[as.list(c(Y,y)), sum(prob), by = eval(paste(colnames(configs), "(t)", sep =""))]
print(P[as.list(c(Y,y)),])
print(ft_1)
print(ft)
colnames(ft_1) = c(colnames(configs), "prob")
print(ft_1)
ft$prob = ft$prob*ft_1$prob / sum(ft$prob*ft_1$prob)
fr$y = Y
fr$ft = data.frame(ft)
fr$mt = mt
return(fr)
}
markov_sim_Y(process, 3,"Y")
stepY <- function(fr, configs, Py, target, P, prob_cols) {
"
Simulate step of markov process with marginalized variables without conditioning
--------------------
Arguments:
fr - simulation vector consisting of y,ft,mt
- y: Y(t) simulated
- ft: P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
- mt: P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
Returns:
fr - simulation vector
"
y = fr$y
ft = fr$ft # probability of P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
mt = fr$mt # P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
for (i in 1:n) {
colmn = prob_cols[i]
mt[i] = sum(as.vector(unlist(Py[as.list(c(y)), ..colmn])) * as.vector(unlist(ft["prob"])))
}
Y = sample.int(n, 1, prob = mt) - 1
ft_1 = P[as.list(c(Y,y)), sum(prob), by = eval(paste(colnames(configs), "(t)", sep =""))]
print(P[as.list(c(Y,y)),])
print(ft_1)
print(ft)
colnames(ft_1) = c(colnames(configs), "prob")
print(ft_1)
print(ft$prob*ft_1$prob)
ft$prob = ft$prob*ft_1$prob / sum(ft$prob*ft_1$prob)
fr$y = Y
fr$ft = data.frame(ft)
fr$mt = mt
return(fr)
}
markov_sim_Y(process, 2,"Y")
stepY <- function(fr, configs, Py, target, P, prob_cols) {
"
Simulate step of markov process with marginalized variables without conditioning
--------------------
Arguments:
fr - simulation vector consisting of y,ft,mt
- y: Y(t) simulated
- ft: P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
- mt: P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
Returns:
fr - simulation vector
"
y = fr$y
ft = fr$ft # probability of P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
mt = fr$mt # P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
for (i in 1:n) {
colmn = prob_cols[i]
print(Py[as.list(c(y)),])
print(ft)
mt[i] = sum(as.vector(unlist(Py[as.list(c(y)), ..colmn])) * as.vector(unlist(ft["prob"])))
}
Y = sample.int(n, 1, prob = mt) - 1
ft_1 = P[as.list(c(Y,y)), sum(prob), by = eval(paste(colnames(configs), "(t)", sep =""))]
print(P[as.list(c(Y,y)),])
colnames(ft_1) = c(colnames(configs), "prob")
ft$prob = ft$prob*ft_1$prob / sum(ft$prob*ft_1$prob)
fr$y = Y
fr$ft = data.frame(ft)
fr$mt = mt
return(fr)
}
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 1,"Y")
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
table(out$y)/n_2
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y")
markov_sim_Y <- function(obj,
n,
target = "Y",
condition_set = NULL) {
"
Simulate process with marginalized variables
----------------------
Arguments:
obj - markov_process object
target - name of variable to be simulated
condition_set - vector of nodes to condition by, NULL if no conditioning is applied
"
numb = obj@dim_num
target_parent_nodes = names(which(obj@parent_struct[target, ] == 1))
parent_without_target = target_parent_nodes[target_parent_nodes != target]
prob_cols = obj@prob_cols
if (sum(obj@node_names == target) < 1) {
print("Target out of scope")
return(NULL)
}
if (length(parent_without_target) == 0) {
print("Target variable has no other parents")
return(NULL)
}
if (is.null(condition_set)) {
#######################################
# preparation of relevant distributions
Py = obj@trans_prob[[target]]
Py = relocate(Py, target, .before = 1)
setkeyv(Py, c(target, parent_without_target))
P = setDT(obj@trans_matrix_list)
setkeyv(P, c(paste(target, "(t)", sep = ""), paste(target, "(t-1)", sep = "")))
#######################################
# preparation for simulation vector
fty = vector("list", c(3))
names(fty) = c("y", "ft", "mt")
fty$y = 0 # y(t)
configs = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(parent_without_target)))
colnames(configs) = parent_without_target
values = matrix(1 / nrow(configs),
ncol = 1,
nrow = row(configs)) # P(X(t) |Y(t)=y,Y(<t)) X may be multidimensional
colnames(values) = "prob"
fty$ft = data.table(cbind(configs, values))
setkeyv(fty$ft, parent_without_target)
fty$ft = data.frame(fty$ft)
fty$mt = c(1:obj@dim_num)    #P(Y(t+1) |Y(t)=y,Y(<t))
########################################
# preparation for memory vectors
Ys = rep(NULL, n) # history of target
Fts = vector("list", n) # estimates of fts
Mts = matrix(NA,ncol=numb,nrow=n) # estimates of mt
colnames(Mts) = prob_cols
timer = Sys.time()
for (t in 1:n) {
fty = stepY(fty, configs, Py, target, P, prob_cols)
Ys[t] = fty$y
Fts[[t]] = fty$ft
Mts[t,] = fty$mt
print_progress(t, n, timer)
}
}
else{
# Not Implemented Yet
print("Conditioning not implemented yet")
fty = NULL
}
out = fty
out$y = Ys
out$ft = Fts
out$mt = Mts
return(out)
}
stepY <- function(fr, configs, Py, target, P, prob_cols) {
"
Simulate step of markov process with marginalized variables without conditioning
--------------------
Arguments:
fr - simulation vector consisting of y,ft,mt
- y: Y(t) simulated
- ft: P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
- mt: P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
Returns:
fr - simulation vector
"
y = fr$y
ft = fr$ft # probability of P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
mt = fr$mt # P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
for (i in 1:n) {
colmn = prob_cols[i]
mt[i] = sum(as.vector(unlist(Py[as.list(c(y)), ..colmn])) * as.vector(unlist(ft["prob"])))
}
Y = sample.int(n, 1, prob = mt) - 1
ft_1 = P[as.list(c(Y,y)), sum(prob), by = eval(paste(colnames(configs), "(t)", sep =""))]
colnames(ft_1) = c(colnames(configs), "prob")
ft$prob = ft$prob*ft_1$prob / sum(ft$prob*ft_1$prob)
fr$y = Y
fr$ft = data.frame(ft)
fr$mt = mt
return(fr)
}
out = markov_sim_Y(process, n_2,"Y")
table(out$y)
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
#------------------------------------------------------------------------
#markov process simulation
#m=10^7
m = 10 ^4
attr(process, "simulation_trial") = markov_sim(process, m)
X = process@simulation_trial[, "X"]
Z = process@simulation_trial[, "Z"]
Y = process@simulation_trial[, "Y"]
table(X, Y, Z) / m
table(process@simulation_trial) / m
process@simulation_trial
table(X, Y, Z) / m
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
process@statio_prob
table(X, Y, Z) / m
d = 2
set.seed(1)
#define parent structure
ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
rownames(ParentStructure) = colnames(ParentStructure) = tail(LETTERS, d)
ParentStructure[2, 3] = 1
n = 2
d = 3
set.seed(1)
#define parent structure
ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
rownames(ParentStructure) = colnames(ParentStructure) = tail(LETTERS, d)
ParentStructure[2, 3] = 1
ParentStructure[3, 1] = 1
ParentStructure[3, 2] = 1
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = proc_init(n, d, ParentStructure)
process@trans_prob
attr(process, "trans_matrix") = trans_matrix(process)
attr(process, "statio_prob") = stationary_probability(process)
process@statio_prob
# simulate marginalized markov process
n_2 = 10000
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y")
table(out$y)
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
table(out$y)/n_2
# simulate marginalized markov process
n_2 = 1000
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
# simulate marginalized markov process
n_2 = 100
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
# simulate marginalized markov process
n_2 = 50
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
# simulate marginalized markov process
n_2 = 200
out = markov_sim_Y(process, n_2,"Y")
table(out$y)
# simulate marginalized markov process
n_2 = 400
out = markov_sim_Y(process, n_2,"Y")
table(out$y)
stepY <- function(fr, configs, Py, target, P, prob_cols) {
"
Simulate step of markov process with marginalized variables without conditioning
--------------------
Arguments:
fr - simulation vector consisting of y,ft,mt
- y: Y(t) simulated
- ft: P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
- mt: P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
Returns:
fr - simulation vector
"
y = fr$y
ft = fr$ft # probability of P(X(t) |Y(t)=y,Y(<t)): probs of configurations of X
mt = fr$mt # P(Y(t+1)|Y(t)=y,Y(<t)): vector of length n
for (i in 1:n) {
colmn = prob_cols[i]
mt[i] = sum(as.vector(unlist(Py[as.list(c(y)), ..colmn])) * as.vector(unlist(ft["prob"])))
}
Y = sample.int(n, 1, prob = mt) - 1
ft_1 = P[as.list(c(Y,y)), sum(prob), by = eval(paste(colnames(configs), "(t)", sep =""))]
colnames(ft_1) = c(colnames(configs), "prob")
print(ft)
ft$prob = ft$prob*ft_1$prob / sum(ft$prob*ft_1$prob)
fr$y = Y
fr$ft = data.frame(ft)
fr$mt = mt
return(fr)
}
markov_sim_Y(process, 1,"Y")
markov_sim_Y(process, 4,"Y")
markov_sim_Y(process, 400,"Y")
process@statio_prob
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
# simulate marginalized markov process
n_2 = 400
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
# simulate marginalized markov process
n_2 = 400
out = markov_sim_Y(process, n_2,"Y")
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
table(out$y)/n_2
hist(Fts[Ys==1])
process@trans_prob
n = 2
d = 2
#define parent structure
ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
rownames(ParentStructure) = colnames(ParentStructure) = tail(LETTERS, d)
ParentStructure[1,2] = 1
ParentStructure
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = proc_init(n, d, ParentStructure)
process@trans_prob
attr(process, "trans_matrix") = trans_matrix(process)
attr(process, "statio_prob") = stationary_probability(process)
process@statio_prob
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
n = 3
#define parent structure
ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
rownames(ParentStructure) = colnames(ParentStructure) = tail(LETTERS, d)
ParentStructure[1,2] = 1
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = proc_init(n, d, ParentStructure)
process@trans_prob
attr(process, "trans_matrix") = trans_matrix(process)
attr(process, "statio_prob") = stationary_probability(process)
process@statio_prob
# simulate marginalized markov process
n_2 = 400
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
n = 6
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = proc_init(n, d, ParentStructure)
process@trans_prob
attr(process, "trans_matrix") = trans_matrix(process)
attr(process, "statio_prob") = stationary_probability(process)
process@statio_prob
# simulate marginalized markov process
n_2 = 400
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
n = 4
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = proc_init(n, d, ParentStructure)
process@trans_prob
attr(process, "trans_matrix") = trans_matrix(process)
attr(process, "statio_prob") = stationary_probability(process)
process@statio_prob
# simulate marginalized markov process
n_2 = 400
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
# simulate marginalized markov process
n_2 = 900
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y")
table(out$y)
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
# simulate marginalized markov process
n_2 = 4000
out = markov_sim_Y(process, n_2,"Y")
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
n = 3
# simulate marginalized markov process
n_2 = 2000
out = markov_sim_Y(process, n_2,"Y")
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y")
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = proc_init(n, d, ParentStructure)
process@trans_prob
attr(process, "trans_matrix") = trans_matrix(process)
attr(process, "statio_prob") = stationary_probability(process)
attr(process,"trans_matrix_list") = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y")
process@trans_prob
process@trans_prob$Z^100
process@trans_prob$Z[c("prob_1","prob_2","prob_3")]
process@trans_prob$Z[,c("prob_1","prob_2","prob_3")]
process@trans_prob$Z[,c("prob_0","prob_1","prob_2")]
process@trans_prob$Z[,c("prob_0","prob_1","prob_2")]%^%100
process@trans_prob$Z[,c("prob_0","prob_1","prob_2")]^2
as.matrix(process@trans_prob$Z[,c("prob_0","prob_1","prob_2")])^2
as.matrix(process@trans_prob$Z[,c("prob_0","prob_1","prob_2")])^100
as.matrix(process@trans_prob$Z[,c("prob_0","prob_1","prob_2")])*as.matrix(process@trans_prob$Z[,c("prob_0","prob_1","prob_2")])
as.matrix(process@trans_prob$Z[,c("prob_0","prob_1","prob_2")])%*%as.matrix(process@trans_prob$Z[,c("prob_0","prob_1","prob_2")])
test = as.matrix(process@trans_prob$Z[,c("prob_0","prob_1","prob_2")])%*%as.matrix(process@trans_prob$Z[,c("prob_0","prob_1","prob_2")])
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test = test%*%test
test
