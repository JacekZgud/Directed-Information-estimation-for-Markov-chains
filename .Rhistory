NoParents = rowSums(parent_struct)
for (node in Nodenames) {
parents = Nodenames[which(parent_struct[node,] == 1)]
n0_parents = NoParents[parents]
temp = expand.grid(rep(list(0:c(n - 1)), length(n0_parents)))
colnames(temp) = parents
if (NoParents[[node]] != 0) {
prob_matr = matrix(
sample.int(10 ^ 3, n * nrow(temp)),
nrow = nrow(temp),
ncol = n,
byrow = TRUE
)
colnames(prob_matr) = prob_vector_names
prob_matr = t(apply(prob_matr, 1, function(x)
x / sum(x)))
TransitionProbabilities[[node]] = data.table(cbind(temp, prob_matr))
setkeyv(TransitionProbabilities[[node]], parents)
}
else{
prob_matr = matrix(runif(n),
nrow = 1,
ncol = n,
byrow = TRUE)
colnames(prob_matr) = prob_vector_names
prob_matr = t(apply(prob_matr, 1, function(x)
x / sum(x)))
TransitionProbabilities[[node]] = data.table(prob_matr)
}
}
return(TransitionProbabilities)
}
marginalized_runner <-
function(obj,
target = c(obj@node_names[1]),
n = 1000,
printer = FALSE) {
if (nrow(obj@trans_matrix_list) == 0) {
obj@trans_matrix_list = trans_matrix(obj, list_form = TRUE)
}
if (nrow(obj@statio_prob) == 0) {
obj@statio_prob = stationary_probability(obj)
}
obj@marg_sim = markov_sim_Y(obj, n, target)
if (printer) {
for (i in target) {
message(table(obj@marg_sim$sim_target[, i]) / n)
message(data.table(obj@statio_prob)[, sum(statio_prob), by = eval(i)])
}
}
return(obj)
}
simulation_runner <- function(obj, m = 1000, printer = FALSE) {
if (nrow(obj@statio_prob) == 0)
obj@statio_prob = stationary_probability(obj)
obj@simulation = markov_sim(obj, m)
message('DONE')
if (printer) {
for (i in obj@node_names) {
message(table(obj@simulation[, i]) / m)
message(data.table(obj@statio_prob)[, sum(statio_prob), by = eval(i)])
}
}
return(obj)
}
# example
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
# parametrise the code
node_dim = 2
nodes = 2
work_names = c("X", "Y")
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 1] = 1
ParentStructure[1, 1] = 1
prob = seq(from = 1 / 2,
to = 0.99999,
length.out = 50)
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = (trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
'Y' %in% c('X',2)
'Y' %in% c('X','Y')
c('Y') %in% c('X','Y')
c('Y','X') %in% c('X','Y')
# example
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
# parametrise the code
node_dim = 2
nodes = 2
work_names = c("X", "Y")
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 1] = 1
ParentStructure[1, 1] = 1
prob = seq(from = 1 / 2,
to = 0.99999,
length.out = 50)
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = (trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
# example
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
# parametrise the code
node_dim = 2
nodes = 2
work_names = c("X", "Y")
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 1] = 1
ParentStructure[1, 1] = 1
prob = seq(from = 1 / 2,
to = 0.99999,
length.out = 50)
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = (trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
c('Y','X') %in% c()
c('Y','X') %in% list()
?list
# example
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
# example
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
# parametrise the code
node_dim = 2
nodes = 2
work_names = c("X", "Y")
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 1] = 1
ParentStructure[1, 1] = 1
prob = seq(from = 1 / 2,
to = 0.99999,
length.out = 50)
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = (trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
# example
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
# parametrise the code
node_dim = 2
nodes = 2
work_names = c("X", "Y")
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 1] = 1
ParentStructure[1, 1] = 1
prob = seq(from = 1 / 2,
to = 0.99999,
length.out = 50)
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = (trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
infos = c()
n = 10
for (i in c(1:n)) {
infos = infos + Vectorize(info_estimator, 'a')(a = prob, ParentStructure)
print_progress(i,n)
}
# example
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
# parametrise the code
node_dim = 2
nodes = 2
work_names = c("X", "Y")
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 1] = 1
ParentStructure[1, 1] = 1
prob = seq(from = 1 / 2,
to = 0.99999,
length.out = 50)
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = (trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
source('./structs/information_calculation.R')
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = (trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
source('./structs/information_calculation.R')
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = (trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
# example
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
# parametrise the code
node_dim = 2
nodes = 2
work_names = c("X", "Y")
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 1] = 1
ParentStructure[1, 1] = 1
prob = seq(from = 1 / 2,
to = 0.99999,
length.out = 50)
# define function calculating transfer_entropy estimator
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = (trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
infos = c()
n = 10
for (i in c(1:n)) {
infos = infos + Vectorize(info_estimator, 'a')(a = prob, ParentStructure)
print_progress(i,n)
}
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = supressMessages(trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = suppressMessages(trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
info_estimator(1 / 2, ParentStructure)
infos = c()
n = 10
for (i in c(1:n)) {
infos = infos + Vectorize(info_estimator, 'a')(a = prob, ParentStructure)
print_progress(i,n)
}
infos = infos / n
h = function(b) {
1 - b * log(b / (1 / 2), base = 2) - (1 - b) * log((1 - b) / (1 / 2), base =
2)
}
mutual_info = function(x) {
a = x
b = x
c = a * (b ^ 2) + a * ((1 - b) ^ 2) + (1 - a) * (b ^ 2) + 2 * (1 - a) *
b * (1 - b)
c = 1 - ((1 - a) * b ^ 2 + (1 - a) * (1 - b) ^ 2 + 2 * a * b * (1 - b))
h(c) - h(x)
}
dir_pol = function(x) {
1 - h(x)
}
plot(
prob,
infos,
ylim = c(0, 1),
type = 'line',
col = 'green',
xlab = 'a (a=b)',
ylab = 'Information'
)
infos
infos = rep(0,length(prob))
n = 10
n = 1
for (i in c(1:n)) {
infos = infos + Vectorize(info_estimator, 'a')(a = prob, ParentStructure)
print_progress(i,n)
}
infos = infos / n
infos
# example
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
# parametrise the code
node_dim = 2
nodes = 2
work_names = c("X", "Y")
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 1] = 1
ParentStructure[1, 1] = 1
prob = seq(from = 1 / 2,
to = 0.99999,
length.out = 50)
# define function calculating transfer_entropy estimator
info_estimator = function(a, par_struct, n_2 = 1000) {
proc = markov_process_init(node_dim, nodes, par_struct, work_names)
proc@trans_prob$X$prob_1 = c(1 - a, a)
proc@trans_prob$X$prob_0 = 1 - proc@trans_prob$X$prob_1
proc@trans_prob$Y$prob_1 = c(1 - a, a)
proc@trans_prob$Y$prob_0 = 1 - proc@trans_prob$Y$prob_1
proc = suppressMessages(trans_entropy(proc, c('Y'), n = n_2))
return(proc@trans_entropy)
}
#info_estimator(1 / 2, ParentStructure)
infos = rep(0,length(prob))
n = 100
for (i in c(1:n)) {
infos = infos + Vectorize(info_estimator, 'a')(a = prob, ParentStructure)
print_progress(i,n)
}
infos = infos / n
# plot the results
h = function(b) {
1 - b * log(b / (1 / 2), base = 2) - (1 - b) * log((1 - b) / (1 / 2), base =
2)
}
mutual_info = function(x) {
a = x
b = x
c = a * (b ^ 2) + a * ((1 - b) ^ 2) + (1 - a) * (b ^ 2) + 2 * (1 - a) *
b * (1 - b)
c = 1 - ((1 - a) * b ^ 2 + (1 - a) * (1 - b) ^ 2 + 2 * a * b * (1 - b))
h(c) - h(x)
}
dir_pol = function(x) {
1 - h(x)
}
plot(
prob,
infos,
ylim = c(0, 1),
type = 'line',
col = 'green',
xlab = 'a (a=b)',
ylab = 'Information'
)
legend(
"topleft",
legend = c("Transfer entropy",
'M.Information|(t-1)',
'Information Flow'),
pch = "|",
col = c("green", "red", 'blue')
)
curve(
dir_pol,
from = 0.5,
to = 1,
n = 1000,
add = TRUE,
col = 'blue'
)
curve(
mutual_info,
from = 0.5,
to = 1.00000000,
n = 10000,
add = TRUE,
col = 'red'
)
plot(
prob,
infos,
ylim = c(0, 1),
type = 'line',
col = 'green',
xlab = 'a',
ylab = 'Information'
)
legend(
"topleft",
legend = c("Transfer entropy",
'M.Information|(t-1)',
'Information Flow'),
pch = "|",
col = c("green", "red", 'blue')
)
curve(
dir_pol,
from = 0.5,
to = 1,
n = 1000,
add = TRUE,
col = 'blue'
)
curve(
mutual_info,
from = 0.5,
to = 1.00000000,
n = 10000,
add = TRUE,
col = 'red'
)
install.packages("devtools")
library(devtools)
create_package()
create_package(getcwd())
create_package(get_cwd()
)
use_devtools()
create_package("C:\Users\Jacek\Desktop\Markov_simulations")
create_package("C:/Users/Jacek/Desktop/Markov_simulations")
create_package("C:/Users/Jacek/Desktop/Markov_simulations",check_name = FALSE)
