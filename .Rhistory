target,
'\n',
'Other nodes: ',
nodes_without_target_vector,
'\n',
'Transfer_entropy:',
obj@trans_entropy,
'\n'
)
cat('Entropy given all past states:', target_entropy, "\n")
cat('Entropy given only target :', info_niem, '\n')
return(obj)
}
n_2 = 10
node = c('X')
process = marginalized_runner(process, node, n_2)
process = trans_entropy(process, node, n_2 = n_2)
n_2 = 100
process = marginalized_runner(process, node, n_2)
process = trans_entropy(process, node, n_2 = n_2)
n_2 = 1000
process = marginalized_runner(process, node, n_2)
process = trans_entropy(process, node, n_2 = n_2)
# here all functions used to calculate information may be found
# - entropy
# - mutual info
# - transfer entropy
entropy = function(vector, b = 2) {
"
Compute an entropy for vector of probabilities
----------------------------------
Args:
vector - vector of probabilities
"
#if (sum(vector) != 1){
#  cat('Vector is not a probability vector')
#}
vector = vector[(vector != 0)]
out = -sum(vector * log(vector, base = b))
return(out)
}
trans_entropy = function(obj,
target = 'Y',
cond = NULL,
n_2 = 1000) {
"
obj - 'markov_process' class object
"
if ((length(obj@marg_sim) == 0) |
(length(setdiff(obj@marg_sim$target_name, target) > 0) |
length(setdiff(target, obj@marg_sim$target_name) > 0))) {
obj =  marginalized_runner(obj, target, n_2)
}
ft = data.table(obj@marg_sim$ft)
ys = obj@marg_sim$sim_target
target = obj@marg_sim$target_name
nodes_without_target_vector = setdiff(obj@node_names, target)
prob_cols = obj@prob_cols
column_names = c(paste(target, c(
rep("(t)", length(target)), rep("(t-1)", length(target))
), sep = ""),
paste(nodes_without_target_vector, "(t-1)", sep = ""))
origin_prob = data.table(obj@statio_prob)[, sum(statio_prob), keyby =
eval(c(obj@node_names))]
#define P_target
P_target = setDT(obj@trans_matrix_list)[, sum(prob), by = column_names]
colnames(P_target) = c(column_names, 'prob')
setkeyv(P_target, paste(target, rep("(t-1)", length(target)), sep = ""))
#calculate entropy given all previous states of markov chain
target_entropy = sum(P_target[, entropy(prob), keyby = c(paste(obj@node_names, '(t-1)', sep =
""))]$V1 * origin_prob$V1)
cat('Calculating entropies...\n')
end = obj@marg_sim$sim_length
time = Sys.time()
############## new one
#ft = data.table(obj@marg_sim$ft)
#ys = obj@marg_sim$sim_target
entropy_target_calc = function(index) {
print_progress(index, end, time)
entropy(P_target[as.list(ys[index,]), sum(prob * ft[[as.character(index)]]), by =
eval(paste(target,
rep("(t)", length(target)), sep = ""))]$V1)
}
entropy_only_target = Vectorize(entropy_target_calc)(c(1:obj@marg_sim$sim_length))
info_niem = sum(entropy_only_target) / obj@marg_sim$sim_length
attr(obj, 'trans_entropy') = info_niem - target_entropy
cat(
'\n---------------------------------------------------\n',
'Target:',
target,
'\n',
'Other nodes: ',
nodes_without_target_vector,
'\n',
'Transfer_entropy:',
obj@trans_entropy,
'\n'
)
cat('Entropy given all past states:', target_entropy, "\n")
cat('Entropy given only target :', info_niem, '\n')
return(obj)
}
if (sys.nframe() == 0L) {
n_2 = 1000
node = c('X')
process = marginalized_runner(process, node, n_2)
process = trans_entropy(process, node, n_2 = n_2)
}
# here all functions used to calculate information may be found
# - entropy
# - mutual info
# - transfer entropy
require('data.table')
entropy = function(vector, b = 2) {
"
Compute an entropy for vector of probabilities
----------------------------------
Args:
vector - vector of probabilities
"
#if (sum(vector) != 1){
#  cat('Vector is not a probability vector')
#}
vector = vector[(vector != 0)]
out = -sum(vector * log(vector, base = b))
return(out)
}
trans_entropy = function(obj,
target = 'Y',
cond = NULL,
n_2 = 1000) {
"
obj - 'markov_process' class object
"
if ((length(obj@marg_sim) == 0) |
(length(setdiff(obj@marg_sim$target_name, target) > 0) |
length(setdiff(target, obj@marg_sim$target_name) > 0))) {
obj =  marginalized_runner(obj, target, n_2)
}
ft = data.table(obj@marg_sim$ft)
ys = obj@marg_sim$sim_target
target = obj@marg_sim$target_name
nodes_without_target_vector = setdiff(obj@node_names, target)
prob_cols = obj@prob_cols
column_names = c(paste(target, c(
rep("(t)", length(target)), rep("(t-1)", length(target))
), sep = ""),
paste(nodes_without_target_vector, "(t-1)", sep = ""))
origin_prob = data.table(obj@statio_prob)[, sum(statio_prob), keyby =
eval(c(obj@node_names))]
#define P_target
P_target = setDT(obj@trans_matrix_list)[, sum(prob), by = column_names]
colnames(P_target) = c(column_names, 'prob')
setkeyv(P_target, paste(target, rep("(t-1)", length(target)), sep = ""))
#calculate entropy given all previous states of markov chain
target_entropy = sum(P_target[, entropy(prob), keyby = c(paste(obj@node_names, '(t-1)', sep =
""))]$V1 * origin_prob$V1)
cat('Calculating entropies...\n')
end = obj@marg_sim$sim_length
time = Sys.time()
############## new one
#ft = data.table(obj@marg_sim$ft)
#ys = obj@marg_sim$sim_target
entropy_target_calc = function(index) {
print_progress(index, end, time)
entropy(P_target[as.list(ys[index,]), sum(prob * ft[[as.character(index)]]), by =
eval(paste(target,
rep("(t)", length(target)), sep = ""))]$V1)
}
entropy_only_target = Vectorize(entropy_target_calc)(c(1:obj@marg_sim$sim_length))
info_niem = sum(entropy_only_target) / obj@marg_sim$sim_length
attr(obj, 'trans_entropy') = info_niem - target_entropy
cat(
'\n---------------------------------------------------\n',
'Target:',
target,
'\n',
'Other nodes: ',
nodes_without_target_vector,
'\n',
'Transfer_entropy:',
obj@trans_entropy,
'\n'
)
cat('Entropy given all past states:', target_entropy, "\n")
cat('Entropy given only target :', info_niem, '\n')
return(obj)
}
if (sys.nframe() == 0L) {
n_2 = 1000
node = c('X')
process = marginalized_runner(process, node, n_2)
process = trans_entropy(process, node, n_2 = n_2)
}
source('./structs/information_calculation.R')
source('./structs/information_calculation.R')
# Chain X->Z->Y
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source('./structs/information_calculation.R')
node_dim = 3
nodes = 3
source("./structs/markov_process.R")
source('./structs/information_calculation.R')
node_dim = 3
nodes = 3
set.seed(1)
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
diag(ParentStructure) = 1
work_names = tail(LETTERS, nodes)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 3] = 1
#ParentStructure[3, 1] = 1
ParentStructure[3, 2] = 1
# ParentStructure[2,5] = 1
# ParentStructure[3,2] = 1
# ParentStructure[1,2] = 1
ParentStructure[1, 2] = 1
ParentStructure[2, 1] = 1
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = markov_process_init(node_dim, nodes, ParentStructure, work_names)
#calculate transfer entropy from V/target -----> target
process = trans_entropy(process, c('Y','Z'), n_2=1000)
process@trans_prob
#calculate transfer entropy from V/target -----> target
process = trans_entropy(process, c('Z'), n_2=1000)
source("./structs/markov_process.R")
source('./structs/information_calculation.R')
#calculate transfer entropy from V/target -----> target
process = trans_entropy(process, c('Z'), n_2=1000)
#calculate transfer entropy from V/target -----> target
process = trans_entropy(process, c('Y'), n_2=1000)
#calculate transfer entropy from V/target -----> target
process = trans_entropy(process, c('Y','Z'), n_2=1000)
source("./structs/markov_process.R")
source('./structs/information_calculation.R')
# here all functions used to calculate information may be found
# - entropy
# - mutual info
# - transfer entropy
require('data.table')
entropy = function(vector, b = 2) {
"
Compute an entropy for vector of probabilities
----------------------------------
Args:
vector - vector of probabilities
"
#if (sum(vector) != 1){
#  cat('Vector is not a probability vector')
#}
vector = vector[(vector != 0)]
out = -sum(vector * log(vector, base = b))
return(out)
}
trans_entropy = function(obj,
target = 'Y',
cond = NULL,
n = 1000) {
"
obj - 'markov_process' class object
"
if ((length(obj@marg_sim) == 0) |
(length(setdiff(obj@marg_sim$target_name, target) > 0) |
length(setdiff(target, obj@marg_sim$target_name) > 0))) {
obj =  marginalized_runner(obj, target, n)
}
ft = data.table(obj@marg_sim$ft)
ys = obj@marg_sim$sim_target
target = obj@marg_sim$target_name
nodes_without_target_vector = setdiff(obj@node_names, target)
prob_cols = obj@prob_cols
column_names = c(paste(target, c(
rep("(t)", length(target)), rep("(t-1)", length(target))
), sep = ""),
paste(nodes_without_target_vector, "(t-1)", sep = ""))
origin_prob = data.table(obj@statio_prob)[, sum(statio_prob), keyby =
eval(c(obj@node_names))]
#define P_target
P_target = setDT(obj@trans_matrix_list)[, sum(prob), by = column_names]
colnames(P_target) = c(column_names, 'prob')
setkeyv(P_target, paste(target, rep("(t-1)", length(target)), sep = ""))
#calculate entropy given all previous states of markov chain
target_entropy = sum(P_target[, entropy(prob), keyby = c(paste(obj@node_names, '(t-1)', sep =
""))]$V1 * origin_prob$V1)
cat('Calculating entropies...\n')
end = obj@marg_sim$sim_length
time = Sys.time()
entropy_target_calc = function(index) {
print_progress(index, end, time)
entropy(P_target[as.list(ys[index,]), sum(prob * ft[[as.character(index)]]), by =
eval(paste(target,
rep("(t)", length(target)), sep = ""))]$V1)
}
entropy_only_target = Vectorize(entropy_target_calc)(c(1:obj@marg_sim$sim_length))
info_niem = sum(entropy_only_target) / obj@marg_sim$sim_length
attr(obj, 'trans_entropy') = info_niem - target_entropy
cat(
'\n---------------------------------------------------\n',
'Target:',
target,
'\n',
'Other nodes: ',
nodes_without_target_vector,
'\n',
'Transfer_entropy:',
obj@trans_entropy,
'\n'
)
cat('Entropy given all past states:', target_entropy, "\n")
cat('Entropy given only target :', info_niem, '\n')
return(obj)
}
if (sys.nframe() == 0L) {
n_2 = 1000
node = c('X')
process = marginalized_runner(process, node, n_2)
process = trans_entropy(process, node, n_2 = n_2)
}
process = trans_entropy(process, node, n = n_2)
entr = function(x) x*log(1/x)+(1-x)\log(1/(1-x))
entr = function(x) x*log(1/x)+(1-x)*log(1/(1-x))
curve(entr)
curve(entr,xlab = 'p',ylab='H(X_p)')
curve(entr,xlab = 'p',ylab='H(Xp)')
entr = function(x) x*log(1/x,base=2)+(1-x)*log(1/(1-x),base=2)
curve(entr,xlab = 'p',ylab='H(Xp)')
?curve
curve(entr,xlab = 'p',ylab='H(Xp)' )
KL
?KL
philentropy
?philentropy
(1/3)log(2/3,base=2) + (2/3)log(4/3,base=2) +
(1/3)*log(2/3,base=2) + (2/3)*log(4/3,base=2)
(1/2)*log(3/4,base=2) + (1/2)*log(3/2,base=2)
# Chain X->Z->Y
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source('./structs/information_calculation.R')
node_dim = 3
nodes = 3
set.seed(1)
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
diag(ParentStructure) = 1
work_names = c("X", "Y")
work_names = tail(LETTERS, nodes)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 3] = 1
#ParentStructure[3, 1] = 1
ParentStructure[3, 2] = 1
# ParentStructure[2,5] = 1
# ParentStructure[3,2] = 1
# ParentStructure[1,2] = 1
ParentStructure[1, 2] = 1
ParentStructure[2, 1] = 1
ParentStructure
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = markov_process_init(node_dim, nodes, ParentStructure, work_names)
# simulate marginalized markov process
n_2 = 10 ^ 3
process = marginalized_runner(process, c('Y', 'Z'), n = n_2)
#calculate transfer entropy from V/target -----> target
process = trans_entropy(process, c('Y', 'Z'), n = 1000)
process@trans_prob
node_dim = 3
nodes = 3
set.seed(1)
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
diag(ParentStructure) = 1
work_names = c("X", "Y")
work_names = tail(LETTERS, nodes)
rownames(ParentStructure) = colnames(ParentStructure) = work_names
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = markov_process_init(node_dim, nodes, ParentStructure, work_names)
ParentStructure
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = markov_process_init(node_dim, nodes, ParentStructure, work_names)
#calculate transfer entropy from V/target -----> target
process = trans_entropy(process, c('Y', 'Z'), n = 1000)
#calculate transfer entropy from V/target -----> target
process = trans_entropy(process, c('Y', 'Z'), n = 10000)
#calculate transfer entropy from V/target -----> target
process = trans_entropy(process, c('X'), n = 10000)
dkl_comp = function(x,inv=FALSE){
x = as.numeric(x)
if (inv){
P = c(1/3,2/3)
Q = c(x,1-x)
}
else{
Q = c(1/3,2/3)
P = c(x,1-x)
}
sum(P*log(P/Q,base=2))
}
dkl_comp_fixed_inv_vec <- Vectorize(function(x) {
dkl_comp(x, inv = TRUE)
})
dkl_comp_vec <- Vectorize(function(x) {
dkl_comp(x, inv = FALSE)
})
# Plot the curve using the modified vectorized function
xes = c(0.01,0.99)
curve(dkl_comp_fixed_inv_vec, from = xes[1], to = xes[2],xlab='p',ylab='DKL',col='red')
curve(dkl_comp_vec, from = xes[1], to = xes[2],add=TRUE,col='blue')
legend(
"topleft",
legend = c("D_Q","D_P"),
pch = "|",
col = c("red", 'blue')
)
dkl_comp = function(x,inv=FALSE){
x = as.numeric(x)
if (inv){
P = c(1/10,9/10)
Q = c(x,1-x)
}
else{
Q = c(1/10,9/10)
P = c(x,1-x)
}
sum(P*log(P/Q,base=2))
}
dkl_comp_fixed_inv_vec <- Vectorize(function(x) {
dkl_comp(x, inv = TRUE)
})
dkl_comp_vec <- Vectorize(function(x) {
dkl_comp(x, inv = FALSE)
})
# Plot the curve using the modified vectorized function
xes = c(0.01,0.99)
curve(dkl_comp_fixed_inv_vec, from = xes[1], to = xes[2],xlab='p',ylab='DKL',col='red')
curve(dkl_comp_vec, from = xes[1], to = xes[2],add=TRUE,col='blue')
legend(
"topleft",
legend = c("D_Q","D_P"),
pch = "|",
col = c("red", 'blue')
)
dkl_comp = function(x,inv=FALSE){
x = as.numeric(x)
if (inv){
P = c(1/2,1/2)
Q = c(x,1-x)
}
else{
Q = c(1/2,1/2)
P = c(x,1-x)
}
sum(P*log(P/Q,base=2))
}
dkl_comp_fixed_inv_vec <- Vectorize(function(x) {
dkl_comp(x, inv = TRUE)
})
dkl_comp_vec <- Vectorize(function(x) {
dkl_comp(x, inv = FALSE)
})
# Plot the curve using the modified vectorized function
xes = c(0.01,0.99)
curve(dkl_comp_fixed_inv_vec, from = xes[1], to = xes[2],xlab='p',ylab='DKL',col='red')
curve(dkl_comp_vec, from = xes[1], to = xes[2],add=TRUE,col='blue')
legend(
"topleft",
legend = c("D_Q","D_P"),
pch = "|",
col = c("red", 'blue')
)
# Plot the curve using the modified vectorized function
xes = c(0.001,0.999)
curve(dkl_comp_fixed_inv_vec, from = xes[1], to = xes[2],xlab='p',ylab='DKL',col='red')
curve(dkl_comp_vec, from = xes[1], to = xes[2],add=TRUE,col='blue')
legend(
"topleft",
legend = c("D_Q","D_P"),
pch = "|",
col = c("red", 'blue')
)
curve(dkl_comp_fixed_inv_vec, from = xes[1], to = xes[2],xlab='p',ylab='',col='red')
curve(dkl_comp_vec, from = xes[1], to = xes[2],add=TRUE,col='blue')
legend(
"topleft",
legend = c("D_Q","D_P"),
pch = "|",
col = c("red", 'blue')
)
# example
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
node_dim = 2
nodes = 2
#define parent structure
ParentStructure = matrix(nrow = nodes, ncol = nodes, data = 0)
work_names = c("X", "Y")
rownames(ParentStructure) = colnames(ParentStructure) = work_names
ParentStructure[2, 1] = 1
ParentStructure[1, 1] = 1
ParentStructure
