ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
rownames(ParentStructure) = colnames(ParentStructure) = tail(LETTERS,d)
ParentStructure[2, 3] = 1
ParentStructure[3, 1] = 1
#ParentStructure[2,5] = 1
#ParentStructure[3,2] = 1
NoParents = rowSums(ParentStructure)
#initalize class for markov_simulations
process = proc_init(n,d,ParentStructure)
process@trans_prob
attr(process,"trans_matrix") = trans_matrix(process)
attr(process,"statio_prob") = stationary_probability(process)
sum(process@statio_prob[process@statio_prob["X"]==1,]["statio_prob"])
sum(process@statio_prob[process@statio_prob["X"]==0,]["statio_prob"])
process@trans_prob
#######
#markov process simulation
#m=10^7
m=1
attr(process,"simulation_trial") = markov_sim(process,m)
sample(2,c(1/2,1/2))
sample(2,1,c(1/2,1/2))
sample(2,1,prob=c(1/2,1/2))
sample(2,1,prob=c(1/2,1/2))
sample(2,1,prob=c(1/2,1/2))
sample(2,1,c(1/2,1/2))
sample(2,1,prob=c(1/2,1/2))
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 1:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
Prob = Prob[as.list(ParentState),]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample(c(0:(n-1)),1,prob=Prob)
}
return(NewState)
}
#######
#markov process simulation
#m=10^7
m=1
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
Prob = Prob[as.list(ParentState),]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample(c(0:(n-1)),1,prob=Prob)
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
Prob = Prob[as.list(ParentState),]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
print(Prob)
NewState[vertex] =  sample(c(0:(n-1)),1,prob=Prob)
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
Prob = Prob[as.list(ParentState), ..prob_columns]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample(c(0:(n-1)),1,prob=Prob)
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
attr(process,"simulation_trial") = markov_sim(process,m)
process@simulation_trial
attr(process,"simulation_trial") = markov_sim(process,m)
attr(process,"simulation_trial") = markov_sim(process,m)
process@simulation_trial
sample(c(0:(n-1)),1,prob=Prob)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
Prob = Prob[as.list(ParentState), ..prob_columns]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample(c(0:(n-1)),1,prob=Prob)
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
process@simulation_trial
sample(2,1,prob=c(1/2,1/2))
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,1,prob=c(1/2,1/2))-1
sample(2,100,prob=c(1/2,1/2))-1
sample(2,100,prob=c(1/2,1/2))
sample(2,2,prob=c(1/2,1/2))
sample(2,2,prob=c(1/2,1/2))
sample(2,2,prob=c(1/2,1/2))
sample(2,2,prob=c(1/2,1/2))-1
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
Prob = Prob[as.list(ParentState), ..prob_columns]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
process@simulation_trial
attr(process,"simulation_trial") = markov_sim(process,m)
process@simulation_trial
attr(process,"simulation_trial") = markov_sim(process,m)
process@simulation_trial
attr(process,"simulation_trial") = markov_sim(process,m)
process@simulation_trial
attr(process,"simulation_trial") = markov_sim(process,m)
process@simulation_trial
attr(process,"simulation_trial") = markov_sim(process,m)
process@simulation_trial
stationary_probability(process)
styler:::set_style_transformers()
#visuals
print_progress <- function(iteration, total, start_time=Sys.time()) {
percent_complete <- round((iteration / total) * 100 / 5)
time_elapsed = Sys.time() - start_time
cat(
"\r[",
paste(rep("=", percent_complete), collapse = ""),
paste(rep(" ", 20 - percent_complete), collapse = ""),
"] ",
percent_complete * 5,
"%",
" (",
iteration,
"/",
total,
"), ",
time_elapsed %/% 60,
"min",
time_elapsed %% 60,
sep = ""
)
flush.console()
}
#######
#markov process simulation
#m=10^7
m=100
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
Prob = Prob[as.list(ParentState), ..prob_columns]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
print(Prob)
Prob = Prob[as.list(ParentState), ..prob_columns]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
print(Prob)
print(prob_columns)
Prob = Prob[as.list(ParentState), ..prob_columns]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
print(Prob)
print(prob_columns)
Prob = Prob[as.list(ParentState), prob_columns]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
print(Prob)
print(prob_columns)
Prob = Prob[as.list(ParentState), ..prob_columns]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
print(Prob)
print(prob_columns)
Prob = Prob[as.list(ParentState),]
print(Prob)
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
print(Prob)
print(prob_columns)
Prob = Prob[as.list(ParentState)]
print(Prob)
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
print(Prob)
print(prob_columns)
Prob = Prob[as.list(ParentState), ..prob_columns]
print(Prob)
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
?[.data.frame
?`[.data.frame`
# Chain X->Z->Y
library(dplyr)
library(data.table)
source("./structs/functions.R")
n = 3
d = 3
set.seed(1)
#define relation structure
ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
rownames(ParentStructure) = colnames(ParentStructure) = tail(LETTERS,d)
ParentStructure[2, 3] = 1
ParentStructure[3, 1] = 1
#ParentStructure[2,5] = 1
#ParentStructure[3,2] = 1
NoParents = rowSums(ParentStructure)
#initalize class for markov_simulations
process = proc_init(n,d,ParentStructure)
process@trans_prob
#########################################
#transition matrix
#takes some time to calculate, approx 30 sec for n=3 and d=4.
attr(process,"trans_matrix") = trans_matrix(process)
attr(process,"statio_prob") = stationary_probability(process)
sum(process@statio_prob[process@statio_prob["X"]==1,]["statio_prob"])
sum(process@statio_prob[process@statio_prob["X"]==0,]["statio_prob"])
process@trans_prob
#######
#markov process simulation
#m=10^7
m=100
attr(process,"simulation_trial") = markov_sim(process,m)
#visuals
print_progress <- function(iteration, total, start_time=Sys.time()) {
percent_complete <- round((iteration / total) * 100 / 5)
cat(
"\r[",
paste(rep("=", percent_complete), collapse = ""),
paste(rep(" ", 20 - percent_complete), collapse = ""),
"] ",
percent_complete * 5,
"%",
" (",
iteration,
"/",
total,
"), ",
difftime(Sys.time(),start_time,format="auto" ),
sep = ""
)
flush.console()
}
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
print(Prob)
print(prob_columns)
Prob = Prob[as.list(ParentState), ..prob_columns]
print(Prob)
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
#visuals
print_progress <- function(iteration, total, start_time=Sys.time()) {
percent_complete <- round((iteration / total) * 100 / 5)
cat(
"\r[",
paste(rep("=", percent_complete), collapse = ""),
paste(rep(" ", 20 - percent_complete), collapse = ""),
"] ",
percent_complete * 5,
"%",
" (",
iteration,
"/",
total,
"), ",
difftime(Sys.time(),start_time,units = "auto" ),
sep = ""
)
flush.console()
}
attr(process,"simulation_trial") = markov_sim(process,m)
# One step of Markov Chain
#
Step = function(State, TransitionProbabilities,names,ParentStructure) {
NewState = numeric()
prob_columns = paste("prob", 0:(n - 1), sep = "_")
for (vertex in names) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
Prob = TransitionProbabilities[[vertex]]
Prob = Prob[as.list(ParentState), ..prob_columns]
#NewState[vertex] = sum(runif(1) < cumsum(as.vector(Prob)))
NewState[vertex] =  sample.int(n,1,prob=Prob) - 1
}
return(NewState)
}
attr(process,"simulation_trial") = markov_sim(process,m)
attr(process,"simulation_trial") = markov_sim(process,m)
#######
#markov process simulation
#m=10^7
m=1000
attr(process,"simulation_trial") = markov_sim(process,m)
#######
#markov process simulation
#m=10^7
m=100000
attr(process,"simulation_trial") = markov_sim(process,m)
#visuals
print_progress <- function(iteration, total, start_time=Sys.time()) {
percent_complete <- round((iteration / total) * 100 / 5)
cat(
"\r[",
paste(rep("=", percent_complete), collapse = ""),
paste(rep(" ", 20 - percent_complete), collapse = ""),
"] ",
percent_complete * 5,
"%",
" (",
iteration,
"/",
total,
"), ",
difftime(Sys.time(),start_time,units = "secs" ),
sep = ""
)
flush.console()
}
