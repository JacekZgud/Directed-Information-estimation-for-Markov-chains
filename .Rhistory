lines(volt$filt,col="red")
lines(volt$smooth,col='blue')
polygon(c(time(volt2s),rev(time(volt2s))), c(ci[,1],rev(ci[,2])),
col=rgb(0,0,0.6,0.2), border=FALSE)
plot(volt$volatility, type='n',ylim = c(-3,5))
lines(volt$filt,col="red")
lines(volt$smooth[-1],col='blue')
polygon(c(time(volt2s),rev(time(volt2s))), c(ci[,1],rev(ci[,2])),
col=rgb(0,0,0.6,0.2), border=FALSE)
mod=dlmModPoly(1,C0=0.2830709,dV=1) # variance of \sigma_e  0.3632
voltFilt = dlmFilter(volt,mod)
Ct <-unlist( with(voltFilt, dlmSvd2var(U.C, D.C)))
voltSMT = dlmSmooth(voltFilt)
volt$smooth = voltSMT$s[-341]
St <-unlist(  with(voltSMT, dlmSvd2var(U.S, D.S)) )
Rt <- unlist(with(voltFilt, dlmSvd2var(U.R, D.R))) #variance of nabla 0.6180340
level <- dropFirst(voltFilt$m)
sdC <- abs(dropFirst(voltFilt$D.C))
ci <- drop(sdC%o% qnorm(c(0.025,0.975))) + as.vector(level)
ci2 <- ts(ci)
volt$filt = voltFilt$m[-1]
www<-"https://www.mimuw.edu.pl/~noble/courses/TimeSeries/data/aa-rv-20m.txt"
volt<-read.table(www,header=F)
volt<-log(volt)
mod=dlmModPoly(1,C0=0.2830709,dV=1) # variance of \sigma_e  0.3632
voltFilt = dlmFilter(volt,mod)
Ct <-unlist( with(voltFilt, dlmSvd2var(U.C, D.C)))
voltSMT = dlmSmooth(voltFilt)
volt$smooth = voltSMT$s[-341]
St <-unlist(  with(voltSMT, dlmSvd2var(U.S, D.S)) )
Rt <- unlist(with(voltFilt, dlmSvd2var(U.R, D.R))) #variance of nabla 0.6180340
level <- dropFirst(voltFilt$m)
sdC <- abs(dropFirst(voltFilt$D.C))
ci <- drop(sdC%o% qnorm(c(0.025,0.975))) + as.vector(level)
ci2 <- ts(ci)
volt$filt = voltFilt$m[-1]
colnames(volt)[1] = c("volatility")
volt2s = as.ts(volt)
autoplot(volt2s)
plot(volt$volatility, type='n',ylim = c(-3,5))
lines(volt$filt,col="red")
lines(volt$smooth[-1],col='blue')
polygon(c(time(volt2s),rev(time(volt2s))), c(ci[,1],rev(ci[,2])),
col=rgb(0,0,0.6,0.2), border=FALSE)
plot(volt$volatility, type='n',ylim = c(-3,5))
lines(volt$filt,col="red")
lines(volt$smooth[-1],col='blue')
polygon(c(time(volt2s[-1]),rev(time(volt2s))), c(ci[,1],rev(ci[,2])),
col=rgb(0,0,0.6,0.2), border=FALSE)
plot(volt$volatility, type='n',ylim = c(-3,5))
lines(volt$filt,col="red")
lines(volt$smooth[-1],col='blue')
polygon(c(time(volt2s),rev(time(volt2s))), c(ci[,1],rev(ci[,2])),
col=rgb(0,0,0.6,0.2), border=FALSE)
c(time(volt2s),rev(time(volt2s)))
ci[,1]
plot(volt$volatility, type='n',ylim = c(-3,5))
lines(c(1,volt$filt),col="red")
lines(volt$smooth[-1],col='blue')
polygon(c(time(volt2s[-1]),rev(time(volt2s))), c(ci[,1],rev(ci[,2])),
col=rgb(0,0,0.6,0.2), border=FALSE)
plot(volt$volatility, type='n',ylim = c(-3,5))
lines(c(1,volt$filt),col="red")
lines(volt$smooth[-1],col='blue')
polygon(c(time(volt2s),rev(time(volt2s))), c(ci[,1],rev(ci[,2])),
col=rgb(0,0,0.6,0.2), border=FALSE)
plot(volt$volatility, type='n',ylim = c(-3,5))
lines(c(1,volt$filt),col="red")
lines(volt$smooth,col='blue')
polygon(c(time(volt2s),rev(time(volt2s))), c(ci[,1],rev(ci[,2])),
col=rgb(0,0,0.6,0.2), border=FALSE)
volt$smooth
Ct
mod=dlmModPoly(1,C0=0.6180340,dV=1) # variance of \sigma_e 1
voltFilt = dlmFilter(volt,mod)
Ct <-unlist( with(voltFilt, dlmSvd2var(U.C, D.C))) #variance of nabla 0.6180340
voltSMT = dlmSmooth(voltFilt)
volt$smooth = voltSMT$s[-341]
volt$smooth = voltSMT$s[-341]
voltSMT$s
voltSMT = dlmSmooth(voltFilt)
volt$smooth = voltSMT$s[-341]
residuals(voltFilt)
residuals(voltFilt)
residuals(voltFilt)$sd
volt<-read.table(www,header=F)
www<-"https://www.mimuw.edu.pl/~noble/courses/TimeSeries/data/aa-rv-20m.txt"
volt<-read.table(www,header=F)
volt<-log(volt)
mod=dlmModPoly(1,C0=0.6180340,dV=1)
voltFilt = dlmFilter(volt,mod)
Ct <-unlist( with(voltFilt, dlmSvd2var(U.C, D.C))) #variance of nabla 0.6180340
voltSMT = dlmSmooth(voltFilt)
volt$smooth = voltSMT$s[-341]
St <-unlist(  with(voltSMT, dlmSvd2var(U.S, D.S)) )
residuals(voltFilt)$sd[] # variance of \sigma_e 1.618034
level <- dropFirst(voltFilt$m)
sdC <- abs(dropFirst(voltFilt$D.C))
ci <- drop(sdC%o% qnorm(c(0.025,0.975))) + as.vector(level)
residuals(spfilt)$sd[300]
residuals(spfilt)$sd
residuals(spfilt)$sd[150]
Ct[[169]]
Ct <- with(spfilt, dlmSvd2var(U.C, D.C))
Ct[[169]]
diag(Ct[[169]])
summary(arma)
mod3=dlmModReg(matrix(c(x1[1:751],x2[1:751],x3[1:751]),ncol=3),addInt = FALSE,C0=20*diag(1,3,3),dV=6.123e-05)
ztflt =dlmFilter(zt,mod3)
Rt <- with(ztflt, dlmSvd2var(U.R, D.R))
Ct <- with(ztflt, dlmSvd2var(U.C, D.C))
diag(Ct[[754]])
tester = matrix(c(x1[1:751],x2[1:751],x3[1:751]),ncol=3)
tester = tester*(ztflt$m[-c(1,751,750,749),])
test = tester[,1]+tester[,2]+tester[,3]
mod3s = dlmModPoly(1)
smth=dlmSmooth(test,mod3s)
autoplot(as.ts(smth$s))
autoplot(as.ts(test-x0[c(1:751),]))
residuals(ztfilt)$sd
residuals(ztflt)$sd
residuals(ztflt)$sd
ztflt =dlmFilter(zt,mod3)
Ct <- with(ztflt, dlmSvd2var(U.C, D.C))
mod3=dlmModReg(matrix(c(x1[1:751],x2[1:751],x3[1:751]),ncol=3),addInt = FALSE,C0=20*diag(1,3,3),dV=6.123e-05)
ztflt =dlmFilter(zt,mod3)
Ct <- with(ztflt, dlmSvd2var(U.C, D.C))
diag(Ct[[754]])
residuals(ztflt)$sd
residuals(ztflt)
residuals(voltFilt) # variance of \sigma_e 1.618034
www3<-"https://www.mimuw.edu.pl/~noble/courses/TimeSeries/data/m-ppiaco4709.txt"
PPI<-read.table(www3,header=F)
colnames(PPI) = c('Year','Month','Day','ppi')
zt = diff(log(PPI$ppi))
zt=zt-mean(zt)
arma = arima(zt,order=c(3,0,0))
summary(arma)
x0=data.frame(zt)
x1=zt[-1]
x2=x1[-1]
x3=x2[-1]
mod3=dlmModReg(matrix(c(x1[1:751],x2[1:751],x3[1:751]),ncol=3),addInt = FALSE,C0=20*diag(1,3,3),dV=6.123e-05)
ztflt =dlmFilter(zt,mod3)
Ct <- with(ztflt, dlmSvd2var(U.C, D.C))
diag(Ct[[754]])
residuals(ztflt)
ztflt
residuals(ztflt)
mod3=dlmModReg(matrix(c(x1[1:751],x2[1:751],x3[1:751]),ncol=3),addInt = FALSE,C0=20*diag(1,3,3),dV=0.00006)
ztflt =dlmFilter(zt,mod3)
Ct <- with(ztflt, dlmSvd2var(U.C, D.C))
diag(Ct[[754]])
residuals(ztflt)
6.123e-05
mod3=dlmModReg(matrix(c(x1[1:751],x2[1:751],x3[1:751]),ncol=3),addInt = FALSE,C0=20*diag(1,3,3),dV=6.123e-05)
ztflt =dlmFilter(zt,mod3)
Ct <- with(ztflt, dlmSvd2var(U.C, D.C))
diag(Ct[[754]])
residuals(ztflt)
diag(Ct[[754]])
autoplot(as.ts(test-x0[c(1:751),]))
mod2= dlmModReg(SP500$sp500,C0 = c(1,1) * diag(nrow = 2))
spfilt = dlmFilter(SP500$Pfizer,mod2)
as.ts(spfilt$m)%>%autoplot()
tester = cbind(1,SP500$sp500)
tester = tester*(spfilt$m[-1,])
test = tester[,1]+tester[,2]
autoplot(as.ts(cbind(test,SP500$Pfizer)), facets=FALSE)
Rt <- with(spfilt, dlmSvd2var(U.R, D.R))
diag(Rt[[169]]) # variances of states
diag(Rt[[150]]) # variances of states
autoplot(as.ts(cbind(test,SP500$Pfizer)), facets=FALSE)
summary(fixed)
mod2= dlmModReg(SP500$sp500,C0 = c(1,1) * diag(nrow = 2),dV=0.03795)
spfilt = dlmFilter(SP500$Pfizer,mod2)
as.ts(spfilt$m)%>%autoplot()
tester = cbind(1,SP500$sp500)
tester = tester*(spfilt$m[-1,])
test = tester[,1]+tester[,2]
autoplot(as.ts(cbind(test,SP500$Pfizer)), facets=FALSE)
Rt <- with(spfilt, dlmSvd2var(U.R, D.R))
diag(Rt[[150]]) # variances of innovations
residuals(spfilt)$sd[150] #variance \sigma-e = 1.003229
spSMT = dlmSmooth(spfilt$m,dlmModPoly(2))
autoplot(as.ts(drop(spSMT$s)), facets = FALSE)
autoplot(as.ts(smth$s))
auto.arima(linmodel$residuals,max.p = 10)
www4<-"https://www.mimuw.edu.pl/~noble/courses/TimeSeries/data/d-ibm3dxwkdays8008.txt"
ibm<-read.table(www4,header=T)
y = ibm$ew
x=ibm[,c(12,11,10,9,8)]
linmodel = lm(ew~M+`T`+W+R+1, data=ibm)
summary(linmodel)
checkresiduals(linmodel)
auto.arima(linmodel$residuals,max.p = 10)
checkresiduals(linmodel)
summary(linmodel)
knitr::opts_chunk$set(echo = TRUE)
library(dlm)
library(ggplot2)
library(ggfortify)
library(nnet)
library(forecast)
www5<-"https://www.mimuw.edu.pl/~noble/courses/TimeSeries/data/m-ge2608.txt"
ge<-read.table(www5,header=T)
ge = ge[,2]
# len ge = 927
data = cbind(ge[c(-996,-965,-994)],ge[c(-1,-996,-995)],ge[c(-1,-2,-996)],ge[c(-1,-2,-3)])
colnames(data) = c("t","t-1","t-2","t-3")
model = nnet(t~.,data=data, size =2, linout=TRUE)
summary(model)
pred = predict(model, data[,-1], type='raw')
accuracy(as.vector(pred),as.vector(data[,1]))
www5<-"https://www.mimuw.edu.pl/~noble/courses/TimeSeries/data/m-ge2608.txt"
ge<-read.table(www5,header=T)
ge = ge[,2]
# len ge = 927
data = cbind(ge[c(-996,-965,-994)],ge[c(-1,-996,-995)],ge[c(-1,-2,-996)],ge[c(-1,-2,-3)])
colnames(data) = c("t","t-1","t-2","t-3")
model = nnet(t~.,data=data, size =2, linout=TRUE)
summary(model)
pred = predict(model, data[,-1], type='raw')
accuracy(as.vector(pred),as.vector(data[,1]))
```{r network 2}
data =cbind(data, ifelse(data[,2]>0,1,0),ifelse(data[,3]>0,1,0),ifelse(data[,4]>0,1,0) )
colnames(data) = c("t","t-1","t-2","t-3","st-1","st-2","st-3")
model2 = nnet(t~.,data=data, size =5, linout=TRUE)
summary(model2)
pred2 = predict(model2, data[,-1], type='raw')
accuracy(as.vector(pred2),as.vector(data[,1]))
smth$s
# Chain X->Z->Y
library(dplyr)
setwd(getwd())
source("functions.R")
setwd(getwd())
source("functions.R")
setwd("C:/Users/Jacek/Desktop/Markov_symulations")
# Chain X->Z->Y
library(dplyr)
# Chain X->Z->Y
library(dplyr)
library(data.table)
#setwd("C:/Users/Jacek/Desktop/Symulacje Magisterka")
source("functions.R")
n = 3
d = 4
NodeNames = LETTERS[1:d]
ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
rownames(ParentStructure) = colnames(ParentStructure) = NodeNames
ParentStructure[2, 1] = 1
ParentStructure[2, 4] = 1
NoParents = rowSums(ParentStructure)
TransitionProbabilities = vector("list", c(d))
names(TransitionProbabilities) = NodeNames
Trans_prob = function(Nodenames, ParentStructure, n, d) {
prob_vector_names = paste("prob", c(0:(n - 1)), sep = '_')
for (node in NodeNames) {
parents = NodeNames[which(ParentStructure[node,] == 1)]
n0_parents = NoParents[parents]
temp = expand.grid(rep(list(0:c(n - 1)), length(n0_parents)))
colnames(temp) = parents
#temp['prob1'] = runif(nrow(temp))
#print(runif(n*nrow(temp)))
prob_matr = matrix(
runif(n * nrow(temp)),
nrow = nrow(temp),
ncol = n,
byrow = TRUE
)
colnames(prob_matr) = prob_vector_names
prob_matr = t(apply(prob_matr, 1, function(x)
x / sum(x)))
TransitionProbabilities[[node]] = data.table(cbind(temp, prob_matr))
#print(as.matrix(cbind(temp,prob_matr)))
#print(data.table(cbind(temp,prob_matr)))
setkeyv(TransitionProbabilities[[node]], parents)
}
return(TransitionProbabilities)
}
TransitionProbabilities = Trans_prob(Nodenames, ParentStructure, n, d)
TransitionProbabilities[["Z"]]
TransitionProbabilities[["A"]]
trans_matrix = function(n, d) {
Trans = expand.grid(rep(list(0:c(n - 1)), 2 * d))
colnames(Trans) = c(paste(NodeNames, "(t)", sep = ""),
paste(NodeNames, "(t-1)", sep = ""))
Trans['prob'] = apply(Trans, 1, function(x)
prob_transition(x))
Trans2 = matrix(
as.vector(Trans['prob'])$prob,
ncol = n ^ d,
nrow = n ^ d,
byrow = TRUE
)
return(Trans2)
}
start = Sys.time()
Trans = trans_matrix(n, d)
end = Sys.time()
end - start
res_statio
rowSums(Trans)
A = t(Trans - diag(ncol = n ^ d, nrow = n ^ d))
A = rbind(A, rep(1, n ^ d))
b = c(rep(0, n ^ d), 1)
res_statio = qr.solve(A, b)
res_statio = cbind(expand.grid(rep(list(0:c(
n - 1
)), d)), res_statio)
colnames(res_statio) = c(NodeNames, 'statio_prob')
sum(res_statio$statio_prob)
res_statio
m = 10 ^ 4
XZY = matrix(nrow = m, ncol = d)
colnames(XZY) = NodeNames
State = rep(0, d)
for (i in 1:m) {
State = Step(State)
XZY[i, ] = State
}
?setDT
# One step of Markov Chain
#
Step = function(State) {
NewState = c()
prob_columns = paste("prob", c(1:(n - 1)), sep = "_")
for (vertex in NodeNames) {
Parents = (ParentStructure[vertex, ] == 1)
ParentState = State[Parents]
#print(as.list(ParentState))
#loc =  apply(TransitionProbabilities[[vertex]][NodeNames[Parents]], 1, function(x) all(c(x) == ParentState ))
Prob = TransitionProbabilities[[vertex]][as.list(ParentState), ..prob_columns]
#Prob = TransitionProbabilities[[vertex]][loc,prob_columns]
NewState[vertex] = sum(runif(1) > cumsum(as.vector(Prob)))
}
return(NewState)
}
Step(c(1,1,1))
Step(c(1,1,1,1))
profvis::profvis({Step(c(1,1,1,1))})
profvis::profvis({Step(c(1,1,1,1))})
Step(c(1,1,1,1))
start = Sys.time()
Trans = trans_matrix(n, d)
end = Sys.time()
end - start
View(prob_transition)
start = Sys.time()
Trans = trans_matrix(n, d)
profvis::profvis({
start = Sys.time()
Trans = trans_matrix(n, d)
end = Sys.time()
end - start
})
profvis::profvis({
m = 10 ^ 4
XZY = matrix(nrow = m, ncol = d)
colnames(XZY) = NodeNames
State = rep(0, d)
for (i in 1:m) {
State = Step(State)
XZY[i, ] = State
}
})
#setwd("C:/Users/Jacek/Desktop/Symulacje Magisterka")
source("./functions.R")
#setwd("C:/Users/Jacek/Desktop/Symulacje Magisterka")
source("./functions.R")
#setwd("C:/Users/Jacek/Desktop/Symulacje Magisterka")
source("./functions.R")
n = 3
d = 4
# Chain X->Z->Y
library(dplyr)
library(data.table)
#setwd("C:/Users/Jacek/Desktop/Symulacje Magisterka")
source("./functions.R")
#setwd("C:/Users/Jacek/Desktop/Symulacje Magisterka")
source("./structs/functions.R")
n = 3
d = 4
NodeNames = LETTERS[1:d]
ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
rownames(ParentStructure) = colnames(ParentStructure) = NodeNames
ParentStructure[2, 1] = 1
ParentStructure[2, 4] = 1
NoParents = rowSums(ParentStructure)
TransitionProbabilities = vector("list", c(d))
names(TransitionProbabilities) = NodeNames
Trans_prob = function(Nodenames, ParentStructure, n, d) {
prob_vector_names = paste("prob", c(0:(n - 1)), sep = '_')
for (node in NodeNames) {
parents = NodeNames[which(ParentStructure[node,] == 1)]
n0_parents = NoParents[parents]
temp = expand.grid(rep(list(0:c(n - 1)), length(n0_parents)))
colnames(temp) = parents
#temp['prob1'] = runif(nrow(temp))
#print(runif(n*nrow(temp)))
prob_matr = matrix(
runif(n * nrow(temp)),
nrow = nrow(temp),
ncol = n,
byrow = TRUE
)
colnames(prob_matr) = prob_vector_names
prob_matr = t(apply(prob_matr, 1, function(x)
x / sum(x)))
TransitionProbabilities[[node]] = data.table(cbind(temp, prob_matr))
#print(as.matrix(cbind(temp,prob_matr)))
#print(data.table(cbind(temp,prob_matr)))
setkeyv(TransitionProbabilities[[node]], parents)
}
return(TransitionProbabilities)
}
TransitionProbabilities = Trans_prob(Nodenames, ParentStructure, n, d)
TransitionProbabilities[["A"]]
start = Sys.time()
Trans = trans_matrix(n, d)
end = Sys.time()
end - start
rowSums(Trans)
#setwd("C:/Users/Jacek/Desktop/Symulacje Magisterka")
source("./structs/functions.R")
n = 3
d = 4
NodeNames = LETTERS[1:d]
#define relation structure
ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
rownames(ParentStructure) = colnames(ParentStructure) = NodeNames
ParentStructure[2, 1] = 1
ParentStructure[2, 4] = 1
NoParents = rowSums(ParentStructure)
TransitionProbabilities = Trans_prob(Nodenames, ParentStructure, n, d)
TransitionProbabilities
stationry_probability = function(transition_matrix,n,d){
A = t(transition_matrix - diag(ncol = n ^ d, nrow = n ^ d))
A = rbind(A, rep(1, n ^ d))
b = c(rep(0, n ^ d), 1)
res_statio = qr.solve(A, b)
res_statio = cbind(expand.grid(rep(list(0:c(
n - 1
)), d)), res_statio)
colnames(res_statio) = c(NodeNames, 'statio_prob')
return(res_statio)
}
Trans = trans_matrix(n, d)
stationary_probability(Trans,n,d)
stationry_probability(Trans,n,d)
markov_sim(TransitionProbabilities,10^3,d,n)
source
source("./structs/functions.R")
markov_sim(TransitionProbabilities,10^3,d,n)
XZY[, "A"]
X = XZY[, "A"]
XZY = markov_sim(TransitionProbabilities,10^3,d,n)
X = XZY[, "A"]
Z = XZY[, "B"]
Y = XZY[, "C"]
hist(X)
# Chain X->Z->Y
library(dplyr)
library(data.table)
#setwd("C:/Users/Jacek/Desktop/Symulacje Magisterka")
source("./structs/functions.R")
n = 2
d = 2
#set vertices names
NodeNames = LETTERS[1:d]
#define relation structure
ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
rownames(ParentStructure) = colnames(ParentStructure) = NodeNames
ParentStructure[2, 1] = 1
ParentStructure[2, 4] = 1
ParentStructure[2, 1] = 1
NoParents = rowSums(ParentStructure)
TransitionProbabilities = Trans_prob(Nodenames, ParentStructure, n, d)
TransitionProbabilities[["A"]]
Trans = trans_matrix(n, d)
stationary_probability(Trans,n,d)
XZY = markov_sim(TransitionProbabilities,10^3,d,n)
X = XZY[, "A"]
Z = XZY[, "B"]
Y = XZY[, "C"]
hist(X)
# Stationary distribution of X
table(X) / m
XZY
ParentStructure
TransitionProbabilities
stationary_probability(Trans,n,d)
stationary_probability(Trans,n,d)
XZY = markov_sim(TransitionProbabilities,10^3,d,n)
X = XZY[, "A"]
Z = XZY[, "B"]
Y = XZY[, "C"]
hist(X)
# Stationary distribution of X
table(X) / m
PX = c(1 - TransitionProbabilities$X[2, "prob1"], TransitionProbabilities$X[1, "prob1"])
piX = PX / sum(PX)
piX
table(X, Y, Z)
XY.Z0 = table(X[Z == 0], Y[Z == 0])
XY.Z0
mosaicplot(XY.Z0)
