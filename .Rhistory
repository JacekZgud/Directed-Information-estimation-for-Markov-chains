if (length(intersect(obj@node_names, target)) < 1) {
print("Target out of scope")
return(NULL)
}
target_parent_nodes = vector('list')
parent_without_target = vector('list')
nodes_without_target = vector('list')
nodes_not_parent = vector('list')
nodes_without_target_vector = setdiff(obj@node_names, target)
for (i in target) {
target_parent_nodes[[i]] = names(which(obj@parent_struct[i,] == 1))
parent_without_target[[i]] = setdiff(target_parent_nodes[[i]], i)
nodes_without_target[[i]] = setdiff(obj@node_names, i)
nodes_not_parent[[i]] = setdiff(nodes_without_target[[i]], parent_without_target[[i]])
}
prob_cols = obj@prob_cols
if (is.null(condition_set)) {
#######################################
# preparation of relevant distributions
Py = vector('list')
for (i in target) {
Py[[i]] = obj@trans_prob[[i]]
if (length(nodes_not_parent[[i]]) > 0) {
conf = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(nodes_not_parent[[i]])))
colnames(conf) = nodes_not_parent[[i]]
Py[[i]] = data.table(merge(conf, Py[[i]]))
}
Py[[i]] = relocate(Py[[i]], i, .before = 1)
setkeyv(Py[[i]],c(target,nodes_without_target_vector))
}
if (nrow(obj@trans_matrix_list) == 0)
P = setDT(trans_matrix(obj, list_form = TRUE))
else
P = setDT(obj@trans_matrix_list)
setkeyv(P, c(
paste(target, c(rep("(t)",length(target)), rep("(t-1)",length(target))), sep = ""),
paste(nodes_without_target_vector, "(t-1)", sep = "")
))
#######################################
# preparation for simulation vector
fty = vector("list", c(3))
names(fty) = c("y", "ft", "mt")
#y
fty$y = rep(0,length(target))  # y(t)
names(fty$y) = target
#ft
configs = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(nodes_without_target_vector)))
colnames(configs) = nodes_without_target_vector
values = matrix(runif(nrow(configs)),
ncol = 1,
nrow = nrow(configs))
values[, 1] = values[, 1] / sum(values)
colnames(values) = "prob"
fty$ft = data.table(cbind(configs, values)) # P(X(t) |Y(t)=y,Y(<t))
setkeyv(fty$ft, nodes_without_target_vector)
fty$ft = data.frame(fty$ft)
print(fty$ft)
#mt
fty$mt = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(target)))
colnames(fty$mt) = target    #P(Y(t+1) |Y(t)=y,Y(<t))
values = matrix(0,
ncol = 1,
nrow = nrow(fty$mt))
colnames(values) = "prob"
fty$mt['prob'] = values
########################################
# preparation for memory vectors
Ys = matrix(NA,ncol=length(target),nrow=n) # history of target
colnames(Ys) = target
Fts = matrix(NA, ncol = n, nrow = nrow(fty$ft)) # estimates of fts
colnames(Fts) = as.character(1:n)
Fts = cbind(fty$ft[,nodes_without_target_vector],Fts)
Mts = matrix(NA, ncol = n, nrow = nrow(fty$mt)) # estimates of mt
colnames(Mts) = as.character(1:n)
Mts = cbind(fty$mt[,target],Mts)
#setup for timer
timer = Sys.time()
#simulation loop
for (t in 1:n) {
fty = stepY(fty, nodes_without_target_vector, Py, target, P, prob_cols)
Ys[t,] = fty$y
Fts[,as.character(t)] = fty$ft$prob
Mts[,as.character(t)] = fty$mt$prob
print_progress(t, n, timer)
}
}
else{
# Not Implemented Yet
print("Conditioning not implemented yet")
fty = NULL
}
out = fty
out$y = Ys
out$ft = Fts
out$mt = Mts
return(out)
}
markov_sim_Y(process,1,c('Y','Z'))
markov_sim_Y <- function(obj,
n,
target = c("Y"),
condition_set = NULL) {
"
Simulate process with marginalized variables
----------------------
Arguments:
obj - markov_process object
n - length of simulation
target - vector of variable names to be simulated
condition_set - vector of nodes to condition by, NULL if no conditioning is applied
"
numb = obj@dim_num
if (length(intersect(obj@node_names, target)) < 1) {
print("Target out of scope")
return(NULL)
}
target_parent_nodes = vector('list')
parent_without_target = vector('list')
nodes_without_target = vector('list')
nodes_not_parent = vector('list')
nodes_without_target_vector = setdiff(obj@node_names, target)
for (i in target) {
target_parent_nodes[[i]] = names(which(obj@parent_struct[i,] == 1))
parent_without_target[[i]] = setdiff(target_parent_nodes[[i]], i)
nodes_without_target[[i]] = setdiff(obj@node_names, i)
nodes_not_parent[[i]] = setdiff(nodes_without_target[[i]], parent_without_target[[i]])
}
prob_cols = obj@prob_cols
if (is.null(condition_set)) {
#######################################
# preparation of relevant distributions
Py = vector('list')
for (i in target) {
Py[[i]] = obj@trans_prob[[i]]
if (length(nodes_not_parent[[i]]) > 0) {
conf = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(nodes_not_parent[[i]])))
colnames(conf) = nodes_not_parent[[i]]
Py[[i]] = data.table(merge(conf, Py[[i]]))
}
Py[[i]] = relocate(Py[[i]], i, .before = 1)
setkeyv(Py[[i]],c(target,nodes_without_target_vector))
}
if (nrow(obj@trans_matrix_list) == 0)
P = setDT(trans_matrix(obj, list_form = TRUE))
else
P = setDT(obj@trans_matrix_list)
setkeyv(P, c(
paste(target, c(rep("(t)",length(target)), rep("(t-1)",length(target))), sep = ""),
paste(nodes_without_target_vector, "(t-1)", sep = "")
))
#######################################
# preparation for simulation vector
fty = vector("list", c(3))
names(fty) = c("y", "ft", "mt")
#y
fty$y = rep(0,length(target))  # y(t)
names(fty$y) = target
#ft
configs = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(nodes_without_target_vector)))
colnames(configs) = nodes_without_target_vector
values = matrix(runif(nrow(configs)),
ncol = 1,
nrow = nrow(configs))
values[, 1] = values[, 1] / sum(values)
colnames(values) = "prob"
fty$ft = data.table(cbind(configs, values)) # P(X(t) |Y(t)=y,Y(<t))
setkeyv(fty$ft, nodes_without_target_vector)
fty$ft = data.frame(fty$ft)
#mt
fty$mt = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(target)))
colnames(fty$mt) = target    #P(Y(t+1) |Y(t)=y,Y(<t))
values = matrix(0,
ncol = 1,
nrow = nrow(fty$mt))
colnames(values) = "prob"
fty$mt['prob'] = values
########################################
# preparation for memory vectors
Ys = matrix(NA,ncol=length(target),nrow=n) # history of target
colnames(Ys) = target
Fts = matrix(NA, ncol = n, nrow = nrow(fty$ft)) # estimates of fts
colnames(Fts) = as.character(1:n)
print(fty$ft[,nodes_without_target_vector])
Fts = cbind(fty$ft[,nodes_without_target_vector],Fts)
Mts = matrix(NA, ncol = n, nrow = nrow(fty$mt)) # estimates of mt
colnames(Mts) = as.character(1:n)
Mts = cbind(fty$mt[,target],Mts)
#setup for timer
timer = Sys.time()
#simulation loop
for (t in 1:n) {
fty = stepY(fty, nodes_without_target_vector, Py, target, P, prob_cols)
Ys[t,] = fty$y
Fts[,as.character(t)] = fty$ft$prob
Mts[,as.character(t)] = fty$mt$prob
print_progress(t, n, timer)
}
}
else{
# Not Implemented Yet
print("Conditioning not implemented yet")
fty = NULL
}
out = fty
out$y = Ys
out$ft = Fts
out$mt = Mts
return(out)
}
markov_sim_Y(process,1,c('Y','Z'))
markov_sim_Y <- function(obj,
n,
target = c("Y"),
condition_set = NULL) {
"
Simulate process with marginalized variables
----------------------
Arguments:
obj - markov_process object
n - length of simulation
target - vector of variable names to be simulated
condition_set - vector of nodes to condition by, NULL if no conditioning is applied
"
numb = obj@dim_num
if (length(intersect(obj@node_names, target)) < 1) {
print("Target out of scope")
return(NULL)
}
target_parent_nodes = vector('list')
parent_without_target = vector('list')
nodes_without_target = vector('list')
nodes_not_parent = vector('list')
nodes_without_target_vector = setdiff(obj@node_names, target)
for (i in target) {
target_parent_nodes[[i]] = names(which(obj@parent_struct[i,] == 1))
parent_without_target[[i]] = setdiff(target_parent_nodes[[i]], i)
nodes_without_target[[i]] = setdiff(obj@node_names, i)
nodes_not_parent[[i]] = setdiff(nodes_without_target[[i]], parent_without_target[[i]])
}
prob_cols = obj@prob_cols
if (is.null(condition_set)) {
#######################################
# preparation of relevant distributions
Py = vector('list')
for (i in target) {
Py[[i]] = obj@trans_prob[[i]]
if (length(nodes_not_parent[[i]]) > 0) {
conf = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(nodes_not_parent[[i]])))
colnames(conf) = nodes_not_parent[[i]]
Py[[i]] = data.table(merge(conf, Py[[i]]))
}
Py[[i]] = relocate(Py[[i]], i, .before = 1)
setkeyv(Py[[i]],c(target,nodes_without_target_vector))
}
if (nrow(obj@trans_matrix_list) == 0)
P = setDT(trans_matrix(obj, list_form = TRUE))
else
P = setDT(obj@trans_matrix_list)
setkeyv(P, c(
paste(target, c(rep("(t)",length(target)), rep("(t-1)",length(target))), sep = ""),
paste(nodes_without_target_vector, "(t-1)", sep = "")
))
#######################################
# preparation for simulation vector
fty = vector("list", c(3))
names(fty) = c("y", "ft", "mt")
#y
fty$y = rep(0,length(target))  # y(t)
names(fty$y) = target
#ft
configs = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(nodes_without_target_vector)))
colnames(configs) = nodes_without_target_vector
values = matrix(runif(nrow(configs)),
ncol = 1,
nrow = nrow(configs))
values[, 1] = values[, 1] / sum(values)
colnames(values) = "prob"
fty$ft = data.table(cbind(configs, values)) # P(X(t) |Y(t)=y,Y(<t))
setkeyv(fty$ft, nodes_without_target_vector)
fty$ft = data.frame(fty$ft)
#mt
fty$mt = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(target)))
colnames(fty$mt) = target    #P(Y(t+1) |Y(t)=y,Y(<t))
values = matrix(0,
ncol = 1,
nrow = nrow(fty$mt))
colnames(values) = "prob"
fty$mt['prob'] = values
########################################
# preparation for memory vectors
Ys = matrix(NA,ncol=length(target),nrow=n) # history of target
colnames(Ys) = target
Fts = matrix(NA, ncol = n, nrow = nrow(fty$ft)) # estimates of fts
Fts = cbind(fty$ft[,nodes_without_target_vector],Fts)
colnames(Fts) = c(nodes_without_target_vector ,as.character(1:n))
Mts = matrix(NA, ncol = n, nrow = nrow(fty$mt)) # estimates of mt
colnames(Mts) = as.character(1:n)
Mts = cbind(fty$mt[,target],Mts)
#setup for timer
timer = Sys.time()
#simulation loop
for (t in 1:n) {
fty = stepY(fty, nodes_without_target_vector, Py, target, P, prob_cols)
Ys[t,] = fty$y
Fts[,as.character(t)] = fty$ft$prob
Mts[,as.character(t)] = fty$mt$prob
print_progress(t, n, timer)
}
}
else{
# Not Implemented Yet
print("Conditioning not implemented yet")
fty = NULL
}
out = fty
out$y = Ys
out$ft = Fts
out$mt = Mts
return(out)
}
markov_sim_Y(process,1,c('Y','Z'))
markov_sim_Y(process,1000,c('Y','Z'))
# simulate marginalized markov process
n_2 = 10^3
process@trans_matrix_list = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y") # before calculation @trans_matrix_list is advised to be filled.
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
# simulate marginalized markov process
n_2 = 10^3+5
# simulate marginalized markov process
n_2 = 10^5
process@trans_matrix_list = trans_matrix(process,list_form=TRUE)
out = markov_sim_Y(process, n_2,"Y") # before calculation @trans_matrix_list is advised to be filled.
# simulate marginalized markov process
n_2 = 10^4
# simulate marginalized markov process
n_2 = 10^3
out = markov_sim_Y(process, n_2,"Y") # before calculation @trans_matrix_list is advised to be filled.
table(out$y)/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
out = markov_sim_Y(process, n_2,c("Y","Z")) # before calculation @trans_matrix_list is advised to be filled.
table(out$y)/n_2
out$y
table(out$y['Y'])/n_2
out$y['Y']
table(out$y[1])/n_2
table(out$y[,'Y'])/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Y")]
table(out$y[,'Z'])/n_2
data.table(process@statio_prob)[,sum(statio_prob),by=eval("Z")]
process = marginalized_runner(process,c('X'),n_2)
# Chain X->Z->Y
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
# here all functions used to calculate information may be found
# - entropy
# - mutual info
# - transfer entropy
entropy = function(vector, b = 2) {
"
Compute an entropy for vector of probabilities
----------------------------------
Args:
vector - vector of probabilities
"
#if (sum(vector) != 1){
#  cat('Vector is not a probability vector')
#}
vector = vector[(vector != 0)]
out = -sum(vector * log(vector, base = b))
return(out)
}
trans_entropy = function(obj,
target = 'Y',
cond = NULL,
...) {
"
obj - 'markov_process' class object
"
if ((length(obj@marg_sim) == 0) |
(length(setdiff(obj@marg_sim$target_name, target) > 0) |
length(setdiff(target, obj@marg_sim$target_name) > 0))) {
obj =  marginalized_runner(obj, target, 1000)
}
origin = setdiff(obj@node_names, target)
origin_prob = data.table(process@statio_prob)[, sum(statio_prob), keyby =
eval(c(target, origin))]
target_parent_nodes = vector('list')
nodes_not_parent = vector('list')
nodes_without_target_vector = setdiff(obj@node_names, target)
for (i in target) {
target_parent_nodes[[i]] = names(which(obj@parent_struct[i, ] == 1))
nodes_not_parent[[i]] = setdiff(obj@node_names, target_parent_nodes[[i]])
}
prob_cols = obj@prob_cols
Py = vector('list')
entropies_Py = rep(0, obj@dim_num ^ obj@node_num)
for (i in target) {
Py[[i]] = obj@trans_prob[[i]]
if (!(length(nodes_not_parent[[i]]) == 0)) {
conf = expand.grid(rep(list(0:c(
process@dim_num - 1
)), length(nodes_not_parent[[i]])))
colnames(conf) = nodes_not_parent[[i]]
Py[[i]] = data.table(merge(conf, Py[[i]]))
}
setkeyv(Py[[i]], c(obj@node_names))
entropies_Py = entropies_Py + apply(data.frame(Py[[i]])[, prob_cols], 1, entropy) # by conditional independence of target
}
target_entropy = sum(entropies_Py * origin_prob$V1)
mt = data.table(obj@marg_sim$mt)
ys = obj@marg_sim$sim_target
colnames(mt) = c(target, c(1:nrow(obj@marg_sim$sim_target)))
setkeyv(mt, target)
n = nrow(ys)
saver = rep(0, n)
time = Sys.time()
cat('Calculating trajectory probabilities...\n')
for (i in 1:n) {
y = as.vector(ys[i, ])
j = i + length(target)
saver[i] = mt[as.list(c(y)), ..j]
print_progress(i, n, time)
}
cat('\nDONE\n')
probs = cumprod(saver)
#print(obj@trans_prob)
entropy_only_target = apply(mt[,-..target], 2, entropy)
attr(obj, 'trans_entropy') = sum(entropy_only_target * probs / sum(probs)) - target_entropy
cat('Target:',target,'\n','Transfer_entropy:',
sum(entropy_only_target * probs / sum(probs)) - target_entropy,
'\n')
return(obj)
}
#process = trans_entropy(process, c('W'))
# dla mt liczymy końcowo uśrednionie przez prawdopodobienstwo trajektorii
process = trans_entropy(process, c('X'))
process = marginalized_runner(process,c('X'),n_2)
# Chain X->Z->Y
library(dplyr)
library(data.table)
source("./structs/markov_process.R")
source("./structs/stationary_distribution.R")
source("./structs/markov_simulation_src.R")
source("./structs/simulation_marginalized.R")
source('./structs/information_calculation.R')
n = 2
d = 2
set.seed(1)
#define parent structure
ParentStructure = matrix(nrow = d, ncol = d, data = 0)
diag(ParentStructure) = 1
work_names = c("X","Y")
rownames(ParentStructure) = colnames(ParentStructure) = work_names
# ParentStructure[2,5] = 1
# ParentStructure[3,2] = 1
# ParentStructure[1,2] = 1
ParentStructure[1,2] = 1
ParentStructure[2,1] = 1
#------------------------------------------------------------------------
#initialize class for markov_simulations
process = markov_process_init(n, d, ParentStructure,work_names)
process@trans_prob$X$prob_1 = c(0.05, 0.05, 0.95, 0.95)
process@trans_prob$X$prob_0 = 1-process@trans_prob$X$prob_1
process@trans_prob$Y$prob_1 = c(0.45, 0.45, 0.55, 0.55)
process@trans_prob$Y$prob_0 = 1 - process@trans_prob$Y$prob_1
# simulate marginalized markov process
n_2 = 10^3
process = marginalized_runner(process,c('X'),n_2)
process = trans_entropy(process, c('X'))
process@marg_sim$target
process@trans_prob
process = trans_entropy(process, c('Y'))
process = trans_entropy(process, c('X'))
process@trans_prob$Y$prob_1 = c(0.35, 0.35, 0.65, 0.65)
process@trans_prob$Y$prob_0 = 1 - process@trans_prob$Y$prob_1
process = trans_entropy(process, c('Y'))
process@trans_prob
process@trans_prob$Y$prob_1 = c(0.65, 0.35, 0.35, 0.65)
process@trans_prob$Y$prob_0 = 1 - process@trans_prob$Y$prob_1
process = marginalized_runner(process,c('Y'),n_2)
process = trans_entropy(process, c('Y'))
process@trans_prob
process@trans_prob$Y$prob_1 = c(1, 0, 1, 0)
process@trans_prob$Y$prob_0 = 1 - process@trans_prob$Y$prob_1
process = trans_entropy(process, c('Y'))
process = marginalized_runner(process,c('Y'),n_2)
process = trans_entropy(process, c('Y'))
